<!DOCTYPE html>
<html> 
  <head>
    <title>Just a test of p5.js in an github page</title> 
  </head>
  <body>
	<!--This draws the canvas on the webpage -->
    <canvas id="mycanvas"></canvas> 
  </body>
 
  <!-- Include the processing.js library -->
  <!-- See https://khanacademy.zendesk.com/hc/en-us/articles/202260404-What-parts-of-ProcessingJS-does-Khan-Academy-support- for differences -->
  <script src="https://cdn.jsdelivr.net/processing.js/1.4.8/processing.min.js"></script> 
  <script>
  var programCode = function(processingInstance) {
    with (processingInstance) {
      	size(400, 400); 
      	frameRate(30);
	var viewer = {
    shapeMethod:false,
    move:false,
    mouse:false,
    incAmount:0.01,
    
};
var d;
var f;
var generator = new Random(1);
var allRanges = [];
noStroke();
function monteCarlo(dir){
    while(true){
        var a = random(1);
        var b = random(1);
        if(dir){
            if(b>a){
                return(b);
            }
        }else{
            if(b<a){
                return(b);
            }
       }
    }
    //nice clean bracket :-)
}
var range = function(timeOff, steep, rangeHeight, coloring){
    if(viewer.shapeMethod){
        this.timeOff = random(50);
    }else{
        this.timeOff = timeOff;
    }
    this.steepness = steep;
    this.rangeHeight = rangeHeight;
    this.coloring = coloring;
    this.rand = random(1);
    this.trees = [];
};
range.prototype.addTrees = function(){
    d = round(new Random(1).nextGaussian()*500);//y is the tree count
    var currentRange = this;
    var nextRange = allRanges[allRanges.indexOf(this)+1];
    for(var x=0; x<d; x++){//x is the current tree
        var position = random(4);//set the x of the tree to a noise "time"
        if(allRanges.length-1===allRanges.indexOf(currentRange)){
            currentRange.trees.push({
                x:position*100,
                y:map(monteCarlo(false),0,1,400,windowHeight-noise(position+currentRange.timeOff)*windowHeight*currentRange.steepness/2-this.rangeHeight),
                myPosition:position,
            }); 
        }else if(windowHeight-noise(position+nextRange.timeOff)*windowHeight*nextRange.steepness/2-nextRange.rangeHeight>windowHeight-noise(position+currentRange.timeOff)*windowHeight*currentRange.steepness/2-currentRange.rangeHeight+20){
            currentRange.trees.push({
                x:position*100,
                y:map(monteCarlo(false),0,1,windowHeight-noise(position+nextRange.timeOff)*windowHeight*nextRange.steepness/2-nextRange.rangeHeight,
                windowHeight-noise(position+currentRange.timeOff)*windowHeight*currentRange.steepness/2-currentRange.rangeHeight),
                myPosition:position,
            }); 
        }

        
    }
};
range.prototype.displayTrees = function(){
    strokeWeight(5);
    var e=6;
    stroke(12-(allRanges.length-allRanges.indexOf(this)+1)*e, 110-(allRanges.length-allRanges.indexOf(this)+1)*e, 37-(allRanges.length-allRanges.indexOf(this)+1)*e);
    for(var x=1;x<this.trees.length;x++){
        point(this.trees[x].x,this.trees[x].y);
    }
    strokeWeight(0);
};
range.prototype.display = function(){
    fill(0, 0, 0);
            text(this.timeOff,10,(allRanges.indexOf(this)+1)*10);
    for (var t = 0; t < viewer.incAmount*windowWidth; t += viewer.incAmount) {
        var n;
        if(!viewer.move){
            n = noise(t+this.timeOff);
            
        }else{
            n = noise(t+this.timeOff+((allRanges.indexOf(this)+1)*mouseX/-2000)*viewer.mouse+frameCount/200);
        }
        fill(110, 84, 31);
        var y = map(n, 0, 1, 0, windwHeight*this.steepness/2);
        f = -7;//-20 for cool effect  -11 normal
        fill(110+(allRanges.length-allRanges.indexOf(this)+1)*f,84+(allRanges.length-allRanges.indexOf(this)+1)*f,(allRanges.length-allRanges.indexOf(this)+1)*f);
        rect(t*100, windowHeight-y-this.rangeHeight, 1, y+this.rangeHeight);
        strokeWeight(1);
        stroke(0, 0, 0);
        point(t*100,windowHeight-y-this.rangeHeight);
        noStroke();
    }

};
allRanges.push(new range(13,2.3,70,color(0,0,0)));

allRanges.push(new range(17,2,50,color(0,0,0)));
allRanges.push(new range(48.231,1,100,color(0,0,0)));
allRanges.push(new range(5,1,0,color(255, 0, 0)));
allRanges.push(new range(2,0.5,-10,color(166, 166, 166)));
for(var x=0;x<allRanges.length-1;x++){
    allRanges[x].addTrees();
}
allRanges[4].addTrees();

draw = function() {
    background(40, 222, 235);
    //background(0,0,0);
    
    for(var x = 0; x<allRanges.length;x++){
        allRanges[x].display();
        allRanges[x].displayTrees();
    }
    
    fill(255, 0, 0);
    text(d,50,50);
};

	      
    }};

  // Get the canvas that ProcessingJS will use
  var canvas = document.getElementById("mycanvas"); 
  // Pass the function to ProcessingJS constructor
  var processingInstance = new Processing(canvas, programCode); 
  </script>
</html>
